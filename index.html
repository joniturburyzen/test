<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>EL SEGARRO 3D - MASTER EDITION</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #0a0a14;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            color: white;
            width: 100vw;
            height: 100vh;
            position: fixed;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        #hud {
            position: absolute;
            top: 2%;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4vw;
            background: rgba(0, 0, 0, 0.85);
            padding: 1.8vh 3.5vw;
            border-radius: 3vh;
            border: 2px solid #ffd166;
            box-shadow: 0 0 15px rgba(255, 209, 102, 0.7);
            font-size: 2.8vh;
            font-weight: bold;
            z-index: 100;
            white-space: nowrap;
            backdrop-filter: blur(10px);
            pointer-events: none;
        }

        #score-display,
        #record-display {
            position: absolute;
            top: 2%;
            font-size: 3.2vh;
            font-weight: bold;
            color: #ffd166;
            text-shadow: 0 0 8px rgba(255, 209, 102, 0.9);
            z-index: 100;
            text-align: center;
            width: 30%;
            pointer-events: none;
        }

        #score-display {
            right: 3%;
        }

        #record-display {
            left: 3%;
        }

        #combo-display {
            position: absolute;
            top: 15%;
            right: 5%;
            font-size: 4vh;
            font-weight: bold;
            color: #ff4d4d;
            opacity: 0;
            transition: all 0.3s;
            z-index: 100;
        }

        #combo-display.show {
            opacity: 1;
            transform: scale(1.2);
        }

        #speed-indicator {
            position: absolute;
            bottom: 5%;
            left: 3%;
            width: 25vw;
            height: 1.5vh;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 1vh;
            z-index: 100;
        }

        #speed-bar {
            height: 100%;
            background: linear-gradient(90deg, #06d6a0, #ffd166, #ff4d4d);
            width: 20%;
            transition: width 0.3s;
            border-radius: 1vh;
        }

        #game-over,
        #title-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            background: rgba(10, 10, 20, 0.9);
            transition: opacity 0.5s;
        }

        #game-over {
            display: none;
        }

        #game-over.show {
            display: flex;
        }

        h1 {
            font-size: 8vh;
            color: #ffd166;
            text-shadow: 0 0 20px #ff4d4d;
            margin-bottom: 5vh;
            text-align: center;
        }

        button {
            background: linear-gradient(45deg, #ff4d4d, #ffd166);
            color: white;
            border: none;
            padding: 3vh 10vw;
            font-size: 4vh;
            border-radius: 2vh;
            cursor: pointer;
            font-family: 'Courier New';
            font-weight: bold;
            box-shadow: 0 0 20px rgba(255, 77, 77, 0.5);
        }

        button:hover {
            filter: brightness(1.15);
            transform: scale(1.03);
            transition: 0.15s;
        }

        #audio-message {
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%) scale(0);
            background: #ffd166;
            color: #000;
            padding: 2vh 5vw;
            border-radius: 3vh;
            font-weight: bold;
            transition: 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 300;
        }

        #audio-message.show {
            transform: translateX(-50%) scale(1);
        }

        #controls-hint {
            position: absolute;
            bottom: 10%;
            right: 3%;
            font-size: 1.4vh;
            color: rgba(255, 255, 255, 0.35);
            z-index: 100;
            text-align: right;
            pointer-events: none;
            line-height: 1.8;
        }
    </style>
</head>

<body>
    <div id="game-container">

        <div id="hud">
            <div><span>‚ù§Ô∏è</span> <span id="vidas-count">1</span></div>
            <div><span>üö¨</span> <span id="cigarros-count">0</span>/5</div>
        </div>
        <div id="score-display">SCORE: 0</div>
        <div id="record-display">R√âCORD: 0</div>
        <div id="combo-display">x0</div>
        <div id="speed-indicator">
            <div id="speed-bar"></div>
        </div>
        <div id="controls-hint">‚Üê ‚Üí mover ¬∑ ‚Üë/espacio saltar ¬∑ ‚Üì agachar</div>

        <div id="title-screen">
            <h1>EL SEGARRO 3D</h1>
            <button id="start-btn">EMPEZAR A FUMAR</button>
        </div>

        <div id="game-over">
            <h2 style="font-size: 6vh; color: #ff4d4d;">¬°RECISTA!</h2>
            <p id="final-score" style="font-size: 4vh; margin: 3vh 0;">SCORE: 0</p>
            <button id="restart-btn">OTRA VEZ, AMIGOO</button>
        </div>

        <div id="audio-message">üîä ¬°MUSIQUILLA √ÅRABE ACTIVADA!</div>
    </div>

    <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
  </script>
    <script type="module">
        import * as THREE from 'three';

        // ==================== [C0] CARGADOR DE SPRITES PNG ====================
        class SpriteCharacter {
            /**
             * Crea un personaje 3D billboard con la imagen PNG proporcionada.
             * Soporta transparencia (fondo blanco ‚Üí alpha via canvas).
             * @param {string} url - Ruta al PNG
             * @param {number} w - Ancho del sprite en unidades 3D
             * @param {number} h - Alto del sprite en unidades 3D
             * @param {number} yOffset - Desplazamiento Y (pivot en base del personaje)
             * @param {object} animConfig - Configuraci√≥n de animaci√≥n { bobAmp, bobSpeed, swayAmp, swaySpeed, squishAmp }
             */
            constructor(url, w, h, yOffset, animConfig = {}) {
                this.w = w;
                this.h = h;
                this.yOffset = yOffset;
                this.animConfig = Object.assign({
                    bobAmp: 0.08, bobSpeed: 8, swayAmp: 0.04, swaySpeed: 8, squishAmp: 0.04
                }, animConfig);
                this.group = new THREE.Group();
                this.sprite = null;
                this.shadowMesh = null;
                this.loaded = false;
                this._loadSprite(url, w, h, yOffset);
                this._addShadow();
            }

            _loadSprite(url, w, h, yOffset) {
                const loader = new THREE.TextureLoader();
                loader.load(url, (tex) => {
                    // Construir textura con canal alpha (eliminar fondo blanco via canvas)
                    const img = tex.image;
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx2d = canvas.getContext('2d');
                    ctx2d.drawImage(img, 0, 0);
                    const data = ctx2d.getImageData(0, 0, canvas.width, canvas.height);
                    const d = data.data;
                    for (let i = 0; i < d.length; i += 4) {
                        const r = d[i], g = d[i + 1], b = d[i + 2];
                        // Si el pixel es blanco/casi blanco ‚Üí transparente
                        if (r > 230 && g > 230 && b > 230) {
                            d[i + 3] = 0;
                        } else if (r > 200 && g > 200 && b > 200) {
                            // borde suave
                            const factor = 1 - ((r - 200) / 55);
                            d[i + 3] = Math.floor(factor * 255);
                        }
                    }
                    ctx2d.putImageData(data, 0, 0);

                    const alphaTexture = new THREE.CanvasTexture(canvas);
                    alphaTexture.needsUpdate = true;

                    const mat = new THREE.SpriteMaterial({
                        map: alphaTexture,
                        transparent: true,
                        alphaTest: 0.05,
                        depthWrite: false,
                        sizeAttenuation: true,
                    });

                    this.sprite = new THREE.Sprite(mat);
                    this.sprite.scale.set(w, h, 1);
                    this.sprite.position.y = yOffset;
                    this.group.add(this.sprite);
                    this.loaded = true;
                }, undefined, () => {
                    // Fallback voxel si no carga la imagen
                    console.warn('No se pudo cargar sprite:', url);
                });
            }

            _addShadow() {
                // Elipse oscura en el suelo
                const geo = new THREE.CircleGeometry(0.6, 16);
                const mat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3, depthWrite: false });
                this.shadowMesh = new THREE.Mesh(geo, mat);
                this.shadowMesh.rotation.x = -Math.PI / 2;
                this.shadowMesh.position.y = 0.01;
                this.group.add(this.shadowMesh);
            }

            /**
             * Anima el sprite. Llamar en el loop de render.
             * @param {number} t - Tiempo acumulado (frames o segundos)
             * @param {boolean} isMoving - Si el personaje se est√° moviendo
             * @param {number} groundY - Posici√≥n Y del suelo (para recalcular pivot)
             */
            animate(t, isMoving = true, groundY = 0) {
                if (!this.sprite) return;
                const cfg = this.animConfig;
                if (isMoving) {
                    // Bob vertical (salto sutil de carrera)
                    const bob = Math.abs(Math.sin(t * cfg.bobSpeed)) * cfg.bobAmp;
                    // Sway horizontal (balanceo de cuerpo)
                    const sway = Math.sin(t * cfg.swaySpeed) * cfg.swayAmp;
                    // Squish (aplastamiento en el suelo)
                    const squish = 1 - Math.abs(Math.sin(t * cfg.bobSpeed)) * cfg.squishAmp;
                    this.sprite.position.y = this.yOffset + bob + groundY;
                    this.sprite.scale.set(this.w * (1 / squish), this.h * squish, 1);
                    this.group.rotation.z = sway;
                    // Escalar sombra seg√∫n altura
                    const shadowScale = 1 - bob * 2;
                    this.shadowMesh.scale.set(shadowScale, shadowScale, 1);
                } else {
                    // Idle: breathing
                    const breath = Math.sin(t * 2) * 0.01;
                    this.sprite.position.y = this.yOffset + breath + groundY;
                    this.sprite.scale.set(this.w, this.h + breath * 0.5, 1);
                    this.group.rotation.z = 0;
                }
            }

            get mesh() { return this.group; }
        }

        // ==================== [C1] FACTOR√çA DE PERSONAJES 3D CON SPRITES ====================
        class VoxelFactory {
            static mat(c, emissive = 0x000000) {
                return new THREE.MeshPhongMaterial({ color: c, emissive, flatShading: true });
            }

            /**
             * Protagonista: El Segarro (hombre √°rabe con keffiyeh)
             * Sprite animado con carrera vigorosa
             */
            static createPlayer() {
                const sc = new SpriteCharacter(
                    'protagonista.png',
                    2.8, 4.2, 2.1,
                    { bobAmp: 0.18, bobSpeed: 12, swayAmp: 0.06, swaySpeed: 12, squishAmp: 0.06 }
                );
                // userData para animaci√≥n y referencia
                sc.group.userData.spriteChar = sc;
                sc.group.userData.isPlayer = true;
                return sc.group;
            }

            /**
             * Polic√≠a: Mujer agente que persigue al protagonista
             * Sprite animado con carrera de persecuci√≥n
             */
            static createPolicia(rapido = false) {
                const speed = rapido ? 1.6 : 1.2;
                const sc = new SpriteCharacter(
                    'policia.png',
                    2.5, 4.0, 2.0,
                    { bobAmp: 0.14 * speed, bobSpeed: 10 * speed, swayAmp: 0.05 * speed, swaySpeed: 10 * speed, squishAmp: 0.05 }
                );
                // Polic√≠as r√°pidas tienen tinte azul m√°s intenso
                sc.group.userData.spriteChar = sc;
                sc.group.userData.rapido = rapido;
                if (rapido) {
                    // A√±adir brillo de urgencia (luz puntual roja/azul)
                    const flashLight = new THREE.PointLight(0x0044ff, 1.5, 4);
                    flashLight.position.set(0, 3, 0.5);
                    flashLight.userData.isFlash = true;
                    sc.group.add(flashLight);
                }
                return sc.group;
            }

            static createCigarro() {
                const g = new THREE.Group();
                const c = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 1), this.mat(0xf5f5dc));
                c.rotation.x = Math.PI / 2;
                const b = new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshBasicMaterial({ color: 0xff4500 }));
                b.position.z = -0.55;
                // Halo de brasa
                const glow = new THREE.PointLight(0xff6600, 1.5, 1.5);
                glow.position.set(0, 0, -0.55);
                g.add(c, b, glow);
                return g;
            }

            /**
             * Cerdo: Obst√°culo con sprite del cerdito cartoon
             */
            static createCerdo() {
                const sc = new SpriteCharacter(
                    'cerdo.png',
                    2.2, 2.0, 1.0,
                    { bobAmp: 0.06, bobSpeed: 6, swayAmp: 0.08, swaySpeed: 5, squishAmp: 0.08 }
                );
                sc.group.userData.spriteChar = sc;
                return sc.group;
            }
        }

        // ==================== [C2] MOTOR DE AUDIO PROCEDURAL ====================
        class AudioController {
            constructor() {
                this.ctx = null;
                this.enabled = false;
            }

            init() {
                if (this.ctx) return;
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.enabled = true;
                this.loopMusica();
            }

            play(freq, type = 'sine', dur = 0.2, vol = 0.1) {
                if (!this.enabled) return;
                const o = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                o.type = type;
                o.frequency.value = freq;
                g.gain.setValueAtTime(vol, this.ctx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
                o.connect(g);
                g.connect(this.ctx.destination);
                o.start();
                o.stop(this.ctx.currentTime + dur);
            }

            loopMusica() {
                const notas = [110, 130, 146, 164];
                let i = 0;
                const next = () => {
                    if (this.enabled) {
                        this.play(notas[i], 'sine', 2.0, 0.04);
                        i = (i + 1) % notas.length;
                        setTimeout(next, 2400);
                    }
                };
                next();
            }
        }

        // ==================== [C3] CORE DEL JUEGO ====================
        class SegarroMaster {
            constructor() {
                this.audio = new AudioController();
                this.initThree();
                this.initLogic();
                this.setupEvents();
                this.animate();
            }

            initThree() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0a0a14);
                this.scene.fog = new THREE.FogExp2(0x0a0a14, 0.018);

                this.camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 6, 12);
                this.camera.lookAt(0, 2, 0);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('game-container').appendChild(this.renderer.domElement);

                // Iluminaci√≥n mejorada
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.6));
                const sun = new THREE.DirectionalLight(0xffd166, 1.4);
                sun.position.set(10, 20, 10);
                sun.castShadow = true;
                sun.shadow.mapSize.width = 2048;
                sun.shadow.mapSize.height = 2048;
                this.scene.add(sun);

                // Luz ambiental azulada nocturna
                const nightLight = new THREE.HemisphereLight(0x0a0a3a, 0x001122, 0.5);
                this.scene.add(nightLight);

                // Luz de neon desde abajo (ambiente de calle)
                const streetGlow = new THREE.PointLight(0xff4444, 0.8, 30);
                streetGlow.position.set(0, -2, 5);
                this.scene.add(streetGlow);

                // Carretera
                this.road = new THREE.Mesh(
                    new THREE.PlaneGeometry(16, 1000),
                    new THREE.MeshPhongMaterial({ color: 0x162447 })
                );
                this.road.rotation.x = -Math.PI / 2;
                this.road.receiveShadow = true;
                this.scene.add(this.road);

                // Grid
                this.grid = new THREE.GridHelper(200, 40, 0xffd166, 0x333355);
                this.grid.position.y = 0.05;
                this.scene.add(this.grid);

                // L√≠neas de carril
                this._addLaneLines();
                // Edificios laterales
                this._addBuildings();
                // Part√≠culas de ambiente
                this._addParticles();

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            _addLaneLines() {
                const lineMat = new THREE.MeshBasicMaterial({ color: 0xffd166, transparent: true, opacity: 0.4 });
                [-2.2, 2.2].forEach(x => {
                    const geo = new THREE.PlaneGeometry(0.12, 900);
                    const line = new THREE.Mesh(geo, lineMat);
                    line.rotation.x = -Math.PI / 2;
                    line.position.set(x, 0.06, -200);
                    this.scene.add(line);
                });
            }

            _addBuildings() {
                const buildingColors = [0x1a1a3a, 0x0d1b2a, 0x16213e, 0x0f3460];
                const windowMat = new THREE.MeshBasicMaterial({ color: 0xffd166, transparent: true, opacity: 0.7 });
                for (let side of [-1, 1]) {
                    for (let z = -200; z < 50; z += 18) {
                        const h = 8 + Math.random() * 12;
                        const w = 3 + Math.random() * 2;
                        const col = buildingColors[Math.floor(Math.random() * buildingColors.length)];
                        const geo = new THREE.BoxGeometry(w, h, 4);
                        const mat = new THREE.MeshPhongMaterial({ color: col });
                        const building = new THREE.Mesh(geo, mat);
                        building.position.set(side * (9 + w / 2), h / 2, z);
                        this.scene.add(building);
                        // Ventanas aleatorias
                        for (let wy = 1; wy < h - 1; wy += 1.8) {
                            for (let wx = -w / 2 + 0.5; wx < w / 2; wx += 1.2) {
                                if (Math.random() > 0.4) {
                                    const wGeo = new THREE.PlaneGeometry(0.6, 0.8);
                                    const wMesh = new THREE.Mesh(wGeo, windowMat);
                                    wMesh.position.set(building.position.x + wx, wy, z - 2.01 * side);
                                    wMesh.rotation.y = side === 1 ? Math.PI : 0;
                                    this.scene.add(wMesh);
                                }
                            }
                        }
                    }
                }
            }

            _addParticles() {
                // Part√≠culas de polvo/ambiente flotando
                const count = 120;
                const geo = new THREE.BufferGeometry();
                const positions = new Float32Array(count * 3);
                for (let i = 0; i < count; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 14;
                    positions[i * 3 + 1] = Math.random() * 6;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 60;
                }
                geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const mat = new THREE.PointsMaterial({ color: 0xffd166, size: 0.08, transparent: true, opacity: 0.5 });
                this.particles = new THREE.Points(geo, mat);
                this.scene.add(this.particles);
            }

            initLogic() {
                this.state = {
                    playing: false, time: 0, score: 0, speed: 4.8, combo: 0,
                    lane: 1, y: 0, vy: 0, jumping: false, agachado: false,
                    vidas: 1, cigs: 0, invulnerable: 0,
                    pakiActive: false, pakiTimer: 0,
                    lanesX: [-4.5, 0, 4.5],
                    record: parseInt(localStorage.getItem('segarroRecord')) || 0
                };
                this.playerGroup = VoxelFactory.createPlayer();
                this.playerGroup.position.set(0, 0, 0);
                this.scene.add(this.playerGroup);
                this.entities = [];
                this._flashTimer = 0;

                document.getElementById('record-display').textContent = `R√âCORD: ${this.state.record}`;
            }

            setupEvents() {
                document.getElementById('start-btn').onclick = () => {
                    document.getElementById('title-screen').style.display = 'none';
                    this.state.playing = true;
                    this.audio.init();
                    document.getElementById('audio-message').classList.add('show');
                    setTimeout(() => document.getElementById('audio-message').classList.remove('show'), 3000);
                };
                document.getElementById('restart-btn').onclick = () => location.reload();

                // --- TECLADO ---
                window.addEventListener('keydown', e => {
                    if (!this.state.playing) return;
                    switch (e.code) {
                        case 'ArrowLeft': case 'KeyA':
                            if (this.state.lane > 0) this.state.lane--;
                            this._flipSprite(this.playerGroup, -1);
                            break;
                        case 'ArrowRight': case 'KeyD':
                            if (this.state.lane < 2) this.state.lane++;
                            this._flipSprite(this.playerGroup, 1);
                            break;
                        case 'ArrowUp': case 'KeyW': case 'Space':
                            e.preventDefault();
                            if (!this.state.jumping) { this.state.vy = 0.45; this.state.jumping = true; this.audio.play(400); }
                            break;
                        case 'ArrowDown': case 'KeyS':
                            this.agachar();
                            break;
                    }
                });

                // --- T√ÅCTIL (SWIPES) ---
                let sx, sy;
                window.addEventListener('touchstart', e => {
                    sx = e.touches[0].clientX;
                    sy = e.touches[0].clientY;
                });
                window.addEventListener('touchend', e => {
                    if (!this.state.playing) return;
                    const dx = e.changedTouches[0].clientX - sx;
                    const dy = e.changedTouches[0].clientY - sy;
                    if (Math.abs(dx) > Math.abs(dy)) {
                        if (dx > 40 && this.state.lane < 2) { this.state.lane++; this._flipSprite(this.playerGroup, 1); }
                        if (dx < -40 && this.state.lane > 0) { this.state.lane--; this._flipSprite(this.playerGroup, -1); }
                    } else {
                        if (dy < -40 && !this.state.jumping) { this.state.vy = 0.45; this.state.jumping = true; this.audio.play(400); }
                        if (dy > 40) this.agachar();
                    }
                });
            }

            _flipSprite(group, dir) {
                // dir: -1 = izquierda, 1 = derecha
                if (group.userData.spriteChar && group.userData.spriteChar.sprite) {
                    group.userData.spriteChar.sprite.scale.x = Math.abs(group.userData.spriteChar.sprite.scale.x) * dir;
                }
            }

            agachar() {
                if (this.state.agachado) return;
                this.state.agachado = true;
                const sc = this.playerGroup.userData.spriteChar;
                if (sc && sc.sprite) {
                    sc.sprite.scale.y = sc.h * 0.5;
                    sc.sprite.position.y = sc.yOffset * 0.5;
                }
                setTimeout(() => {
                    this.state.agachado = false;
                    if (sc && sc.sprite) {
                        sc.sprite.scale.y = sc.h;
                        sc.sprite.position.y = sc.yOffset;
                    }
                }, 600);
            }

            update() {
                if (!this.state.playing) return;

                this.state.time++;
                this.state.score++;
                if (this.state.invulnerable > 0) this.state.invulnerable--;

                const t = this.state.time * 0.016; // aprox segundos

                // Movimiento suave de carril
                const tx = this.state.lanesX[this.state.lane];
                this.playerGroup.position.x += (tx - this.playerGroup.position.x) * 0.15;

                // Salto
                if (this.state.jumping) {
                    this.state.y += this.state.vy;
                    this.state.vy -= 0.02;
                    if (this.state.y <= 0) { this.state.y = 0; this.state.jumping = false; }
                }
                this.playerGroup.position.y = this.state.y;

                // ANIMACI√ìN DEL PROTAGONISTA
                const playerSC = this.playerGroup.userData.spriteChar;
                if (playerSC) {
                    playerSC.animate(t, !this.state.agachado, this.state.y);
                    // Parpadeo cuando est√° invulnerable
                    if (this.state.invulnerable > 0) {
                        const visible = Math.floor(this.state.time / 4) % 2 === 0;
                        if (playerSC.sprite) playerSC.sprite.material.opacity = visible ? 1.0 : 0.2;
                    } else {
                        if (playerSC.sprite) playerSC.sprite.material.opacity = 1.0;
                    }
                }

                // Dificultad
                this.state.speed = 4.8 + Math.floor(this.state.score / 2000) * 0.6;
                this.grid.position.z = (this.state.time * this.state.speed * 0.1) % 5;

                // Part√≠culas de ambiente
                if (this.particles) {
                    this.particles.position.z = (this.state.time * this.state.speed * 0.04) % 60 - 30;
                }

                // Flash de polic√≠as r√°pidas
                this._flashTimer++;
                this.entities.forEach(ent => {
                    const g = ent.mesh;
                    g.children.forEach(child => {
                        if (child.userData && child.userData.isFlash) {
                            child.color.setHex(this._flashTimer % 30 < 15 ? 0x0044ff : 0xff0000);
                        }
                    });
                });

                // Spawn
                if (this.state.time % 70 === 0) this.spawn();

                // Procesar entidades
                const pBox = new THREE.Box3();
                // Caja de colisi√≥n manual del jugador (m√°s ajustada que el sprite)
                pBox.setFromCenterAndSize(
                    new THREE.Vector3(this.playerGroup.position.x, this.playerGroup.position.y + 1.5, this.playerGroup.position.z),
                    new THREE.Vector3(1.0, 3.0, 1.0)
                );

                for (let i = this.entities.length - 1; i >= 0; i--) {
                    const ent = this.entities[i];
                    ent.mesh.position.z += this.state.speed * 0.12;

                    // Animaci√≥n de entidades
                    const sc = ent.mesh.userData.spriteChar;
                    if (sc) {
                        sc.animate(t + i * 0.5, true, 0);
                        // Cerdos: orientar hacia el jugador sutilmente
                        if (ent.type === 'cerdo') {
                            const wobble = Math.sin(t * 3 + i) * 0.05;
                            ent.mesh.rotation.z = wobble;
                        }
                        // Polic√≠as: amenaza visual - lean forward
                        if (ent.type === 'poli') {
                            ent.mesh.rotation.x = -0.08;
                        }
                    }

                    // Caja de colisi√≥n de la entidad
                    const eBox = new THREE.Box3();
                    const entH = ent.type === 'cerdo' ? 1.5 : 3.0;
                    const entW = ent.type === 'cig' ? 0.5 : 0.9;
                    eBox.setFromCenterAndSize(
                        new THREE.Vector3(ent.mesh.position.x, ent.mesh.position.y + entH / 2, ent.mesh.position.z),
                        new THREE.Vector3(entW, entH, 0.9)
                    );

                    if (pBox.intersectsBox(eBox)) {
                        this.onCollision(ent, i);
                        continue;
                    }

                    if (ent.mesh.position.z > 15) {
                        this.scene.remove(ent.mesh);
                        this.entities.splice(i, 1);
                    }
                }

                this.updateUI();
            }

            spawn() {
                const lane = Math.floor(Math.random() * 3);
                const r = Math.random();
                let type, mesh;

                if (r < 0.6) { type = 'poli'; mesh = VoxelFactory.createPolicia(Math.random() < 0.3); }
                else if (r < 0.8) { type = 'cerdo'; mesh = VoxelFactory.createCerdo(); }
                else { type = 'cig'; mesh = VoxelFactory.createCigarro(); }

                mesh.position.set(this.state.lanesX[lane], 0, -100);
                this.scene.add(mesh);
                this.entities.push({ mesh, type });
            }

            onCollision(ent, idx) {
                if (ent.type === 'cig') {
                    this.state.cigs++;
                    this.state.combo++;
                    this.audio.play(600, 'sine', 0.1);
                    if (this.state.cigs >= 5) {
                        this.state.vidas++;
                        this.state.cigs = 0;
                        this.audio.play(800, 'square', 0.3);
                    }
                } else {
                    if (this.state.invulnerable === 0) {
                        this.state.vidas--;
                        this.state.combo = 0;
                        this.state.invulnerable = 90;
                        this.audio.play(100, 'sawtooth', 0.4);
                        if (this.state.vidas <= 0) this.gameOver();
                        // Shake de c√°mara al golpe
                        this._cameraShake = 8;
                    }
                }
                this.scene.remove(ent.mesh);
                this.entities.splice(idx, 1);
            }

            updateUI() {
                document.getElementById('score-display').textContent = `SCORE: ${this.state.score}`;
                document.getElementById('vidas-count').textContent = this.state.vidas;
                document.getElementById('cigarros-count').textContent = this.state.cigs;
                document.getElementById('speed-bar').style.width = `${Math.min(100, (this.state.speed - 4.8) * 20 + 20)}%`;

                const combo = document.getElementById('combo-display');
                if (this.state.combo > 1) {
                    combo.textContent = `x${this.state.combo}`;
                    combo.classList.add('show');
                } else {
                    combo.classList.remove('show');
                }
            }

            gameOver() {
                this.state.playing = false;
                document.getElementById('game-over').classList.add('show');
                document.getElementById('final-score').textContent = `SCORE: ${this.state.score}`;
                if (this.state.score > this.state.record) localStorage.setItem('segarroRecord', this.state.score);
            }

            animate() {
                this.update();

                // Camera shake
                if (this._cameraShake > 0) {
                    this.camera.position.x = (Math.random() - 0.5) * this._cameraShake * 0.05;
                    this.camera.position.y = 6 + (Math.random() - 0.5) * this._cameraShake * 0.03;
                    this._cameraShake--;
                    if (this._cameraShake <= 0) {
                        this.camera.position.set(0, 6, 12);
                    }
                }

                this.renderer.render(this.scene, this.camera);
                requestAnimationFrame(() => this.animate());
            }
        }

        new SegarroMaster();
    </script>
</body>

</html>
