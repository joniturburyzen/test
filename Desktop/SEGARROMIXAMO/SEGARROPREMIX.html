<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>EL SEGARRO 3D - DEFINITIVE EDITION</title>
  <!-- Precarga Three.js -->
  <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.min.js" crossorigin>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
    }

    body {
      background: #0a0a14;
      font-family: 'Courier New', monospace;
      overflow: hidden;
      color: white;
      width: 100vw;
      height: 100vh;
      position: fixed;
    }

    #game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    /* VIGNETTE */
    #game-container::after {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(ellipse at center, transparent 55%, rgba(0, 0, 0, 0.75) 100%);
      pointer-events: none;
      z-index: 50;
    }

    /* HUD */
    #hud {
      position: absolute;
      top: 2%;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 4vw;
      background: rgba(0, 0, 0, 0.85);
      padding: 1.8vh 3.5vw;
      border-radius: 3vh;
      border: 2px solid #ffd166;
      box-shadow: 0 0 20px rgba(255, 209, 102, 0.8), 0 0 40px rgba(255, 209, 102, 0.3);
      font-size: 2.8vh;
      font-weight: bold;
      z-index: 100;
      white-space: nowrap;
      backdrop-filter: blur(10px);
      pointer-events: none;
      animation: hudPulse 3s ease-in-out infinite;
    }

    @keyframes hudPulse {

      0%,
      100% {
        box-shadow: 0 0 20px rgba(255, 209, 102, 0.8)
      }

      50% {
        box-shadow: 0 0 35px rgba(255, 209, 102, 1), 0 0 60px rgba(255, 209, 102, 0.5)
      }
    }

    #score-display,
    #record-display {
      position: absolute;
      top: 2%;
      font-size: 3.2vh;
      font-weight: bold;
      color: #ffd166;
      text-shadow: 0 0 8px rgba(255, 209, 102, 0.9), 0 0 20px rgba(255, 77, 77, 0.5);
      z-index: 100;
      text-align: center;
      width: 30%;
      pointer-events: none;
      transition: transform 0.1s, text-shadow 0.2s;
    }

    #score-display {
      right: 3%;
    }

    #record-display {
      left: 3%;
    }

    #score-display.bump {
      transform: scale(1.3);
      text-shadow: 0 0 20px rgba(255, 209, 102, 1), 0 0 40px rgba(255, 77, 77, 0.9);
    }

    #combo-display {
      position: absolute;
      top: 15%;
      right: 5%;
      font-size: 4.5vh;
      font-weight: bold;
      color: #ff4d4d;
      text-shadow: 0 0 15px rgba(255, 77, 77, 0.9);
      z-index: 100;
      opacity: 0;
      transform: scale(0);
      transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    #combo-display.show {
      opacity: 1;
      transform: scale(1);
    }

    #speed-indicator {
      position: absolute;
      bottom: 5%;
      left: 3%;
      width: 22vw;
      height: 1.2vh;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 1vh;
      z-index: 100;
      overflow: hidden;
    }

    #speed-bar {
      height: 100%;
      background: linear-gradient(90deg, #06d6a0, #ffd166, #ff4d4d);
      width: 20%;
      transition: width 0.4s;
      box-shadow: 0 0 10px rgba(255, 209, 102, 0.7);
    }

    #paki-bar-wrap {
      position: absolute;
      bottom: 8.5%;
      left: 3%;
      width: 22vw;
      height: 0.8vh;
      background: rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 215, 0, 0.3);
      border-radius: 1vh;
      z-index: 100;
      overflow: hidden;
      display: none;
    }

    #paki-bar {
      height: 100%;
      background: linear-gradient(90deg, #ffd700, #fff176);
      width: 100%;
      transition: width 0.1s;
    }

    /* PANTALLA ROJA */
    #red-flash {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 90;
      opacity: 0;
      background: radial-gradient(ellipse at center, rgba(255, 50, 50, 0) 30%, rgba(255, 50, 50, 0.7) 100%);
      transition: opacity 0.05s;
    }

    /* FADE OVERLAY */
    #fade-overlay {
      position: absolute;
      inset: 0;
      background: #0a0a14;
      z-index: 150;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.8s;
    }

    #fade-overlay.active {
      opacity: 1;
    }

    /* LOADING SCREEN */
    #load-screen {
      position: absolute;
      inset: 0;
      background: linear-gradient(160deg, #0a0a14, #0f0c29, #0a0a14);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 600;
      gap: 2.5vh;
    }

    #load-title {
      font-size: 5.5vh;
      color: #ffd166;
      font-weight: bold;
      letter-spacing: 5px;
      text-shadow: 0 0 25px rgba(255, 209, 102, 0.9), 0 0 50px rgba(255, 77, 77, 0.4);
      animation: hudPulse 2s ease-in-out infinite;
    }

    #load-sub {
      font-size: 1.9vh;
      color: rgba(255, 255, 255, 0.45);
      letter-spacing: 3px;
    }

    #load-track {
      width: 28vw;
      min-width: 180px;
      height: 0.5vh;
      background: rgba(255, 255, 255, 0.08);
      border-radius: 1vh;
      overflow: hidden;
    }

    #load-bar {
      height: 100%;
      background: linear-gradient(90deg, #ffd166, #ff4d4d);
      width: 0%;
      transition: width 0.35s ease;
    }

    /* PERSONAJE LOADING */
    #load-char-wrap {
      position: relative;
      height: 28vh;
      display: flex;
      align-items: flex-end;
      justify-content: center;
    }

    #load-canvas {
      height: 28vh;
      width: auto;
      display: none;
      transform-origin: bottom center;
      image-rendering: auto;
    }

    /* Humo del cigarro */
    .smoke {
      position: absolute;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(190, 190, 190, 0.75) 0%, transparent 70%);
      animation: smokeRise 2s ease-out infinite;
      pointer-events: none;
    }

    .s1 {
      width: 14px;
      height: 14px;
      top: 8%;
      right: 18%;
      animation-delay: 0s;
    }

    .s2 {
      width: 10px;
      height: 10px;
      top: 4%;
      right: 22%;
      animation-delay: 0.7s;
    }

    .s3 {
      width: 12px;
      height: 12px;
      top: 11%;
      right: 14%;
      animation-delay: 1.35s;
    }

    @keyframes smokeRise {
      0% {
        transform: translate(0, 0) scale(0.3);
        opacity: 0.9;
      }

      50% {
        transform: translate(5px, -28px) scale(0.9);
        opacity: 0.5;
      }

      100% {
        transform: translate(-3px, -58px) scale(1.7);
        opacity: 0;
      }
    }

    /* TITULO */
    #title-screen {
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, #0f0c29, #1a1a2e, #0f0c29);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 200;
      gap: 6vh;
      overflow: hidden;
    }

    #title-screen::before {
      content: '';
      position: absolute;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, rgba(255, 209, 102, 0.1) 0%, transparent 50%);
      animation: bgPulse 4s ease-in-out infinite;
    }

    @keyframes bgPulse {

      0%,
      100% {
        transform: translate(-25%, -25%) scale(1);
        opacity: 0.5
      }

      50% {
        transform: translate(-25%, -25%) scale(1.2);
        opacity: 1
      }
    }

    #title-screen h1 {
      font-size: 9vh;
      font-weight: bold;
      letter-spacing: 3px;
      text-align: center;
      padding: 0 5vw;
      background: linear-gradient(45deg, #ffd166, #ff4d4d, #ffd166, #ff4d4d);
      background-size: 300% 300%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: pulseTitle 2s infinite, gradientTitle 4s ease infinite;
      z-index: 1;
    }

    @keyframes pulseTitle {

      0%,
      100% {
        transform: scale(1)
      }

      50% {
        transform: scale(1.07)
      }
    }

    @keyframes gradientTitle {

      0%,
      100% {
        background-position: 0% 50%
      }

      50% {
        background-position: 100% 50%
      }
    }

    #start-btn {
      background: linear-gradient(45deg, #ff4d4d, #ffd166, #ff4d4d);
      background-size: 200% 200%;
      color: white;
      border: none;
      padding: 4vh 12vw;
      font-size: 5.5vh;
      border-radius: 4vh;
      cursor: pointer;
      font-weight: bold;
      font-family: 'Courier New';
      box-shadow: 0 0 30px rgba(255, 77, 77, 0.8), 0 0 60px rgba(255, 209, 102, 0.5);
      letter-spacing: 2px;
      animation: gradientTitle 3s ease infinite;
      z-index: 1;
      position: relative;
      overflow: hidden;
      transition: transform 0.2s;
    }

    #start-btn:hover {
      transform: scale(1.07);
    }

    #start-btn::after {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      transform: rotate(45deg);
      animation: btnShine 3s ease-in-out infinite;
    }

    @keyframes btnShine {
      0% {
        transform: translateX(-100%) rotate(45deg)
      }

      50%,
      100% {
        transform: translateX(100%) rotate(45deg)
      }
    }

    /* GAME OVER */
    #game-over {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      background: rgba(0, 0, 0, 0.95);
      padding: 4vh 6vw;
      border-radius: 4vh;
      border: 4px solid #ff4d4d;
      text-align: center;
      z-index: 200;
      box-shadow: 0 0 40px rgba(255, 77, 77, 0.9), 0 0 80px rgba(255, 77, 77, 0.4);
      width: 85%;
      max-width: 75vw;
      transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    #game-over.show {
      transform: translate(-50%, -50%) scale(1);
    }

    #game-over h2 {
      font-size: 5.5vh;
      margin-bottom: 2vh;
      background: linear-gradient(45deg, #ff4d4d, #ffd166, #ff4d4d);
      background-size: 200% 200%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: gradientTitle 2s ease infinite;
    }

    #game-over p {
      font-size: 3.5vh;
      margin-bottom: 2vh;
      color: #ffd166;
      text-shadow: 0 0 10px rgba(255, 209, 102, 0.8);
    }

    #restart-btn {
      background: linear-gradient(45deg, #06d6a0, #118ab2, #06d6a0);
      background-size: 200% 200%;
      color: white;
      border: none;
      padding: 2.5vh 8vw;
      font-size: 4vh;
      border-radius: 3vh;
      cursor: pointer;
      font-weight: bold;
      font-family: 'Courier New';
      box-shadow: 0 4px 25px rgba(6, 214, 160, 0.6);
      width: 90%;
      display: block;
      margin: 0 auto;
      animation: gradientTitle 3s ease infinite;
      transition: transform 0.2s;
    }

    #restart-btn:hover {
      transform: scale(1.05);
    }

    /* AUDIO MSG */
    #audio-message {
      position: absolute;
      bottom: 12%;
      left: 50%;
      transform: translateX(-50%) scale(0);
      background: linear-gradient(90deg, #ffd166, #ff9e6d, #ffd166);
      background-size: 200% 200%;
      color: #0a0a14;
      padding: 2vh 5vw;
      border-radius: 3vh;
      font-weight: bold;
      font-size: 3vh;
      z-index: 300;
      box-shadow: 0 0 25px rgba(255, 209, 102, 0.9);
      animation: gradientTitle 2s ease infinite;
      transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    #audio-message.show {
      transform: translateX(-50%) scale(1);
    }

    /* INSTRUCCIONES */
    #instructions {
      position: absolute;
      bottom: 2%;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(168, 218, 220, 0.5);
      font-size: 1.6vh;
      text-align: center;
      z-index: 100;
      pointer-events: none;
    }
  </style>
</head>

<body>
  <div id="game-container">
    <div id="hud">
      <div><span>â¤ï¸</span> <span id="vidas-count">1</span></div>
      <div><span>ğŸš¬</span> <span id="cigarros-count">0</span>/5</div>
    </div>
    <div id="score-display">SCORE: 0</div>
    <div id="record-display">RÃ‰CORD: 0</div>
    <div id="combo-display">x2</div>
    <div id="speed-indicator">
      <div id="speed-bar"></div>
    </div>
    <div id="paki-bar-wrap">
      <div id="paki-bar"></div>
    </div>
    <div id="red-flash"></div>
    <div id="fade-overlay"></div>

    <!-- LOADING SCREEN -->
    <div id="load-screen">
      <div id="load-title">EL SEGARRO 3D</div>
      <!-- Personaje fumando con humo CSS -->
      <div id="load-char-wrap">
        <canvas id="load-canvas"></canvas>
        <div class="smoke s1"></div>
        <div class="smoke s2"></div>
        <div class="smoke s3"></div>
      </div>
      <div id="load-sub">PREPARANDO EL MATERIAL...</div>
      <div id="load-track">
        <div id="load-bar"></div>
      </div>
    </div>

    <div id="title-screen" style="display:none">
      <h1>EL SEGARRO 3D</h1>
      <button id="start-btn">EMPEZAR A FUMAR</button>
    </div>

    <div id="game-over">
      <h2>Â¡RECISTA!</h2>
      <p id="final-score">SCORE: 0</p>
      <p id="best-record">MEJOR RÃ‰CORD: 0</p>
      <button id="restart-btn">OTRA VEZ, AMIGOO</button>
    </div>

    <div id="audio-message">ğŸ”Š Â¡MUSIQUILLA ÃRABE ACTIVADA!</div>
    <div id="instructions">â† â†’ carriles &nbsp;|&nbsp; â†‘/ESPACIO saltar &nbsp;|&nbsp; â†“ agachar &nbsp;|&nbsp; 3Ã—â†“ rÃ¡pido
      = â‚¬URO</div>
  </div>

  <!-- AnimaciÃ³n loading + Service Worker (sin dependencias, arranca inmediato) -->
  <script>
    (function () {
      // â”€â”€ Protagonista animado en la pantalla de carga â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const cv = document.getElementById('load-canvas');
      const ctx = cv.getContext('2d');
      const img = new Image();
      let animId = null;

      img.onload = function () {
        cv.width = img.naturalWidth;
        cv.height = img.naturalHeight;
        ctx.drawImage(img, 0, 0);
        // Eliminar fondo blanco
        try {
          const id = ctx.getImageData(0, 0, cv.width, cv.height);
          const d = id.data;
          for (let i = 0; i < d.length; i += 4)
            if (d[i] > 238 && d[i + 1] > 238 && d[i + 2] > 238) d[i + 3] = 0;
          ctx.putImageData(id, 0, 0);
        } catch (e) { }
        cv.style.display = 'block';

        // Bob de carrera
        let t = 0;
        (function bob() {
          t++;
          const sy = 1 - Math.abs(Math.sin(t * 0.09)) * 0.055;
          const sx = 1 + Math.abs(Math.sin(t * 0.09)) * 0.035;
          cv.style.transform = 'scaleX(' + sx + ') scaleY(' + sy + ')';
          animId = requestAnimationFrame(bob);
        })();
      };
      img.src = './protagonista.png';

      // â”€â”€ Service Worker para cachÃ© offline/instantÃ¡neo â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', function () {
          navigator.serviceWorker.register('./sw.js').catch(function () { });
        });
      }
    })();
  </script>

  <!-- Importmap: Three.js r169 CDN para GLTFLoader + SkeletonUtils -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.min.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // [A] AUDIO CONTROLLER
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    class Audio3D {
      constructor() { this.ctx = null; this.enabled = false; this.musicPlaying = false; }
      init() {
        if (this.ctx) return;
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.enabled = true;
        this._startMusica();
      }
      _note(freq, type, dur, vol) {
        if (!this.enabled || !this.ctx) return;
        const o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type = type; o.frequency.value = freq;
        g.gain.setValueAtTime(vol, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
        o.connect(g); g.connect(this.ctx.destination);
        o.start(); o.stop(this.ctx.currentTime + dur);
      }
      _startMusica() {
        if (this.musicPlaying) return;
        this.musicPlaying = true;
        const notas = [110, 130.81, 146.83, 164.81, 196.00];
        let i = 0;
        const next = () => {
          if (!this.musicPlaying || !this.ctx) return;
          const o = this.ctx.createOscillator(), g = this.ctx.createGain();
          o.connect(g); g.connect(this.ctx.destination);
          o.type = 'sine'; o.frequency.value = notas[i];
          g.gain.setValueAtTime(0, this.ctx.currentTime);
          g.gain.linearRampToValueAtTime(0.06, this.ctx.currentTime + 0.1);
          g.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1.9);
          o.start(); o.stop(this.ctx.currentTime + 2.0);
          i = (i + 1) % notas.length;
          setTimeout(next, 2400);
        };
        next();
      }
      stopMusica() { this.musicPlaying = false; }
      salto() { this._note(450, 'sine', 0.12, 0.25); }
      suspiro() { this._note(300, 'sine', 0.4, 0.15); }
      choque() { this._note(120, 'square', 0.15, 0.4); }
      cerdo() { this._note(180, 'sawtooth', 0.3, 0.4); }
      euro() { this._note(800, 'sine', 0.1, 0.3); setTimeout(() => this._note(600, 'sine', 0.1, 0.25), 100); }
      tos() { this._note(200, 'square', 0.3, 0.6); setTimeout(() => this._note(100, 'sawtooth', 0.5, 0.3), 100); }
      pakiOn() { this._note(600, 'sine', 0.4, 0.35); }
      vida() { this._note(800, 'square', 0.3, 0.3); }
      gameOver() {
        if (!this.ctx) return;
        [650, 850].forEach((f) => {
          const o = this.ctx.createOscillator(), g = this.ctx.createGain();
          o.connect(g); g.connect(this.ctx.destination);
          o.frequency.value = f; g.gain.value = 0.15; o.start();
          let asc = true;
          const iv = setInterval(() => { o.frequency.value = asc ? f + 200 : f; asc = !asc; }, 300);
          setTimeout(() => { clearInterval(iv); o.stop(); }, 2500);
        });
      }
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // [B] VOXEL FACTORY (solo ayudas, cigarro y escena final)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    class VF {
      static m(c, emissive = 0, transparent = false, opacity = 1) {
        return new THREE.MeshPhongMaterial({ color: c, emissive, flatShading: true, transparent, opacity });
      }
      static box(w, h, d, mat) { return new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat); }

      static createCigarro() {
        const g = new THREE.Group();
        // Cuerpo principal â€” papel blanco-crema, secciÃ³n circular
        const paper = new THREE.Mesh(
          new THREE.CylinderGeometry(0.13, 0.13, 1.55, 10),
          new THREE.MeshPhongMaterial({ color: 0xf0ead6, emissive: 0x0b0b08, shininess: 55 })
        );
        paper.rotation.x = Math.PI / 2;
        // Banda dorada decorativa (anillo de lujo)
        const band = new THREE.Mesh(
          new THREE.CylinderGeometry(0.136, 0.136, 0.09, 10),
          new THREE.MeshPhongMaterial({ color: 0xd4a017, emissive: 0x3d2500, shininess: 160 })
        );
        band.rotation.x = Math.PI / 2; band.position.z = 0.44;
        // Filtro Ã¡mbar
        const filter = new THREE.Mesh(
          new THREE.CylinderGeometry(0.13, 0.13, 0.36, 10),
          new THREE.MeshPhongMaterial({ color: 0xb05a20, emissive: 0x250c00, shininess: 40 })
        );
        filter.rotation.x = Math.PI / 2; filter.position.z = 0.955;
        // Ceniza gris en la punta quemada (cono)
        const ash = new THREE.Mesh(
          new THREE.CylinderGeometry(0.0, 0.13, 0.22, 8),
          new THREE.MeshPhongMaterial({ color: 0x484848, emissive: 0x111111, flatShading: true })
        );
        ash.rotation.x = Math.PI / 2; ash.position.z = -0.885;
        // Brasa viva (naranja-rojo)
        const emberMat = new THREE.MeshBasicMaterial({ color: 0xff4400 });
        const ember = new THREE.Mesh(new THREE.SphereGeometry(0.145, 8, 8), emberMat);
        ember.position.z = -0.82;
        // NÃºcleo blanco-caliente
        const core = new THREE.Mesh(
          new THREE.SphereGeometry(0.068, 6, 6),
          new THREE.MeshBasicMaterial({ color: 0xffe070 })
        );
        core.position.z = -0.82;
        // Halo de brasa (sprite aditivo, siempre mira a cÃ¡mara)
        const glowMat = new THREE.SpriteMaterial({
          color: 0xff5500, transparent: true, opacity: 0.45,
          blending: THREE.AdditiveBlending
        });
        const glow = new THREE.Sprite(glowMat);
        glow.scale.set(1.0, 1.0, 1.0); glow.position.z = -0.82;
        // Luz pulsante cÃ¡lida
        const light = new THREE.PointLight(0xff6600, 3.0, 7.0);
        light.position.z = -0.82;
        // InclinaciÃ³n natural (cigarro no perfectamente horizontal)
        g.rotation.z = 0.12;
        g.add(paper, band, filter, ash, ember, core, glow, light);
        g.userData = { ember, light, glow };
        return g;
      }

      static createHookah() {
        const g = new THREE.Group();
        const base = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.85, 0.14, 10), this.m(0x424242));
        const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.07, 1.8, 8), this.m(0x5d4037)); stem.position.y = 1.07;
        const bowl = new THREE.Mesh(new THREE.SphereGeometry(0.45, 10, 10), this.m(0x8d6e63)); bowl.position.y = 2.1;
        const dish = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.1, 8), this.m(0x333333)); dish.position.y = 2.6;
        const coal = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), new THREE.MeshBasicMaterial({ color: 0xff6600 })); coal.position.y = 2.76;
        const cl = new THREE.PointLight(0xff6600, 1.5, 4); cl.position.y = 2.8;
        for (let i = 0; i < 6; i++) {
          const h = this.box(0.08, 0.08, 0.3, this.m(0x4a148c));
          h.position.set(0.5 + i * 0.25, 1.5 - i * 0.18, 0);
          h.rotation.z = -0.35;
          g.add(h);
        }
        const boquilla = this.box(0.06, 0.06, 0.5, this.m(0x8d6e63)); boquilla.position.set(1.9, 0.42, 0);
        g.add(base, stem, bowl, dish, coal, cl, boquilla);
        return g;
      }

      static createAmigo(skinColor, ropaColor) {
        const g = new THREE.Group();
        const body = this.box(0.6, 0.75, 0.36, this.m(ropaColor)); body.position.y = 0.95;
        const head = this.box(0.44, 0.44, 0.42, this.m(skinColor)); head.position.y = 1.56;
        const eyeL = this.box(0.08, 0.08, 0.05, this.m(0x1a1a1a)); eyeL.position.set(-0.1, 1.6, 0.22);
        const eyeR = this.box(0.08, 0.08, 0.05, this.m(0x1a1a1a)); eyeR.position.set(0.1, 1.6, 0.22);
        g.add(body, head, eyeL, eyeR);
        return g;
      }
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // [B2] GLB CHARACTER FACTORY â€” personajes 3D Mixamo (DAE â†’ GLB vÃ­a Blender)
    //
    //  Carga 3 GLBs optimizados de RECURSOS/ y los anima con AnimationMixer.
    //  Cada instancia es un clon independiente con su propio mixer/esqueleto.
    //
    //  protagonista.glb : Correr + Saltar + Girar  (1 archivo, 3 animaciones)
    //  policia.glb      : PoliCorrer + PoliEnfadado
    //  cerdo.glb        : CerdoCorrer
    //
    //  ESCALA: 1.8  (Blender normaliza DAE cm â†’ GLB metros; 160 cm â†’ 1.6 m â†’ Ã—1.8 = 2.88 u)
    //
    //  ROTACIÃ“N:
    //   Â· Protagonista: rotation.y = 0    â†’ espalda a cÃ¡mara (corre hacia adelante âœ“)
    //   Â· ObstÃ¡culos:   rotation.y = Math.PI â†’ cara al jugador (vienen contra ti âœ“)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    class FBXCharFactory {
      static _base  = { prot: null, poli: null, cerdo: null };
      static _clips = { protRun: null, protJump: null, protChange: null,
                        poliRun: null, poliAngry: null, cerdoRun: null };

      // Elimina el root motion vertical (Hips Y) de un AnimationClip.
      // Evita que el personaje se hunda bajo el suelo durante la animaciÃ³n.
      static _fixHipsY(clip) {
        for (const track of clip.tracks) {
          if (/hips/i.test(track.name) && track.name.endsWith('.position')) {
            const restY = track.values[1]; // altura en la primera clave
            for (let i = 1; i < track.values.length; i += 3) track.values[i] = restY;
          }
        }
        return clip;
      }

      // â”€â”€ Carga GLB con progreso real por bytes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      static _loadGLTF(url, onProgress) {
        const loader = new GLTFLoader();
        return new Promise((resolve, reject) =>
          loader.load(url, resolve, onProgress, reject)
        );
      }

      // â”€â”€ FASE 1 (bloqueante): protagonista â€” 1 GLB con 3 animaciones â”€â”€
      // La barra va de 0â†’60%. El juego arranca al terminar esta fase.
      static async loadPhase1() {
        const bar = document.getElementById('load-bar');
        const onProg = e => {
          if (!bar || !e.total) return;
          bar.style.width = `${Math.round((e.loaded / e.total) * 60)}%`;
        };

        const gltf = await FBXCharFactory._loadGLTF('./RECURSOS/protagonista.glb', onProg);

        FBXCharFactory._base.prot        = gltf.scene;
        const anims = gltf.animations;
        FBXCharFactory._clips.protJump   = FBXCharFactory._fixHipsY(anims.find(a => a.name === 'Saltar')  ?? anims[1] ?? anims[0]);
        FBXCharFactory._clips.protChange = FBXCharFactory._fixHipsY(anims.find(a => a.name === 'Girar')   ?? anims[2] ?? anims[0]);
        FBXCharFactory._clips.protRun    = FBXCharFactory._fixHipsY(anims.find(a => a.name === 'Correr')  ?? anims[0]);
        gltf.scene.traverse(c => {
          if (c.isMesh || c.isSkinnedMesh) { c.castShadow = true; c.receiveShadow = true; }
        });
        if (bar) bar.style.width = '60%';
      }

      // â”€â”€ FASE 2 (background): obstÃ¡culos â€” 3 GLBs en paralelo â”€â”€â”€â”€â”€â”€â”€â”€
      // Arranca en segundo plano mientras el usuario estÃ¡ en el menÃº.
      static async loadPhase2() {
        const bar = document.getElementById('load-bar');
        const prog = [0, 0, 0], tot = [1, 1, 1];
        const refresh = () => {
          if (!bar) return;
          const b = prog.reduce((a, v) => a + v, 0);
          const t = tot.reduce((a, v) => a + v, 0);
          bar.style.width = `${60 + Math.round((b / t) * 40)}%`;
        };
        const mk = i => e => { if (e.total) tot[i] = e.total; prog[i] = e.loaded; refresh(); };

        try {
          const [poliRunGLTF, poliAngryGLTF, cerdoGLTF] = await Promise.all([
            FBXCharFactory._loadGLTF('./RECURSOS/POLICIACORRER.glb', mk(0)),
            FBXCharFactory._loadGLTF('./RECURSOS/POLICIAENFADO.glb', mk(1)),
            FBXCharFactory._loadGLTF('./RECURSOS/CERDOCORRE.glb',    mk(2)),
          ]);

          FBXCharFactory._base.poli       = poliRunGLTF.scene;
          FBXCharFactory._clips.poliRun   = poliRunGLTF.animations[0];
          FBXCharFactory._clips.poliAngry = poliAngryGLTF.animations[0];

          FBXCharFactory._base.cerdo      = cerdoGLTF.scene;
          FBXCharFactory._clips.cerdoRun  = FBXCharFactory._fixHipsY(cerdoGLTF.animations[0]);

          [poliRunGLTF.scene, cerdoGLTF.scene].forEach(sc => {
            sc.traverse(c => {
              if (c.isMesh || c.isSkinnedMesh) { c.castShadow = true; c.receiveShadow = true; }
            });
          });
        } catch(e) {
          console.error('loadPhase2 error:', e);
        }
      }

      // true cuando los obstÃ¡culos ya estÃ¡n disponibles para spawnear
      static get obstaclesReady() {
        return FBXCharFactory._base.poli !== null && FBXCharFactory._base.cerdo !== null;
      }

      // Clona la escena GLB dentro de un Group wrapper limpio.
      // El wrapper tiene la rotaciÃ³n deseada (sin interferencia de ejes de Blender).
      // El inner model conserva las rotaciones internas del GLB intactas.
      static _setup(baseScene, scale, rotY = 0) {
        const inner = SkeletonUtils.clone(baseScene);
        inner.traverse(c => {
          if (c.isMesh || c.isSkinnedMesh) {
            c.castShadow = true;
            c.receiveShadow = true;
            const mats = Array.isArray(c.material) ? c.material : [c.material];
            mats.forEach(m => {
              if (!m) return;
              m.envMapIntensity = 0.6;
              m.needsUpdate = true;
            });
          }
        });
        const wrapper = new THREE.Group();
        wrapper.add(inner);
        wrapper.scale.setScalar(scale);
        wrapper.rotation.y = rotY;
        wrapper._inner = inner; // referencia para AnimationMixer
        return wrapper;
      }

      // â”€â”€ PROTAGONISTA â€” espalda a cÃ¡mara, corre hacia adelante â”€â”€â”€â”€â”€â”€â”€â”€
      static createPlayer() {
        const SCALE = 1.8;
        const wrapper = FBXCharFactory._setup(FBXCharFactory._base.prot, SCALE, Math.PI);
        const inner   = wrapper._inner;

        const mixer      = new THREE.AnimationMixer(inner);
        const anims      = FBXCharFactory._clips;
        const runAction    = mixer.clipAction(anims.protRun);
        const jumpAction   = mixer.clipAction(anims.protJump);
        const changeAction = mixer.clipAction(anims.protChange);

        // Loop suave: interpola el inicio y fin del ciclo para eliminar el salto visual
        runAction.zeroSlopeAtStart = true;
        runAction.zeroSlopeAtEnd   = true;

        jumpAction.setLoop(THREE.LoopOnce, 1);
        jumpAction.clampWhenFinished = true;
        changeAction.setLoop(THREE.LoopOnce, 1);
        changeAction.clampWhenFinished = false;
        runAction.play();

        // Al terminar el giro, volver suavemente al run
        mixer.addEventListener('finished', e => {
          if (e.action === changeAction) {
            changeAction.fadeOut(0.25);
            runAction.reset().fadeIn(0.25).play();
          }
        });

        const aura = new THREE.PointLight(0xffd700, 0, 8);
        aura.position.set(0, 2.9 / SCALE * 0.5, 0);
        wrapper.add(aura);

        wrapper.userData = {
          mixer, runAction, jumpAction, changeAction, auraLight: aura,
          totalH: 2.9, w: 0.8,
          prevSaltando: false, prevCarril: 1,
          baseScale: SCALE,
          isFBX: true
        };
        return wrapper;
      }

      // â”€â”€ POLICÃA â€” cara al jugador, viene contra ti â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      static createPolicia(rapido = false) {
        const SCALE = 1.8;
        const wrapper = FBXCharFactory._setup(FBXCharFactory._base.poli, SCALE, 0);
        const inner   = wrapper._inner;

        const mixer     = new THREE.AnimationMixer(inner);
        const runAction   = mixer.clipAction(FBXCharFactory._clips.poliRun);
        const angryAction = mixer.clipAction(FBXCharFactory._clips.poliAngry);

        if (rapido) {
          angryAction.play();
          wrapper.traverse(c => {
            if ((c.isMesh || c.isSkinnedMesh) && c.material) {
              const mats = Array.isArray(c.material) ? c.material : [c.material];
              mats.forEach(m => { m.emissive = new THREE.Color(0x002244); });
            }
          });
          const rl = new THREE.PointLight(0xff1111, 2.0, 5.5);
          rl.position.set(0, 2.5 / SCALE, 0);
          wrapper.add(rl);
          wrapper.userData.rLight = rl;
        } else {
          runAction.play();
        }

        wrapper.userData = {
          ...wrapper.userData,
          mixer, runAction, angryAction,
          totalH: 2.9, w: 0.8,
          isFBX: true
        };
        return wrapper;
      }

      // â”€â”€ CERDO â€” cara al jugador, viene mÃ¡s lento que la policÃ­a â”€â”€â”€â”€â”€
      static createCerdo() {
        const SCALE = 2.0;
        const wrapper = FBXCharFactory._setup(FBXCharFactory._base.cerdo, SCALE, 0);
        const inner   = wrapper._inner;

        const mixer   = new THREE.AnimationMixer(inner);
        const runAction = mixer.clipAction(FBXCharFactory._clips.cerdoRun);
        runAction.play();

        wrapper.userData = {
          ...wrapper.userData,
          mixer, runAction,
          totalH: 2.4, w: 1.0,
          isFBX: true
        };
        return wrapper;
      }
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // [C] SISTEMA DE PARTÃCULAS 3D
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    class ParticlePool {
      constructor(scene, maxP = 300) {
        this.particles = [];
        this.scene = scene;
        const geo = new THREE.SphereGeometry(0.08, 4, 4);
        for (let i = 0; i < maxP; i++) {
          const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0 });
          const m = new THREE.Mesh(geo, mat);
          m.visible = false;
          scene.add(m);
          this.particles.push({ mesh: m, active: false, v: new THREE.Vector3(), life: 0, maxLife: 0, gravity: 0 });
        }
      }
      emit(pos, color, count = 15, speed = 4, life = 40, gravity = 0.05) {
        let spawned = 0;
        for (const p of this.particles) {
          if (p.active || spawned >= count) continue;
          p.mesh.position.copy(pos);
          p.mesh.material.color.setHex(color);
          p.mesh.material.opacity = 1;
          p.mesh.visible = true;
          p.v.set((Math.random() - 0.5) * speed, (Math.random() - 0.5) * speed + speed * 0.3, (Math.random() - 0.5) * speed);
          p.life = life + Math.random() * 20; p.maxLife = p.life;
          p.gravity = gravity; p.active = true; spawned++;
        }
      }
      emitSmoke(pos) { this.emit(pos, 0xbbbbbb, 3, 0.5, 60, -0.02); }
      update() {
        for (const p of this.particles) {
          if (!p.active) continue;
          p.v.y -= p.gravity;
          p.mesh.position.addScaledVector(p.v, 1 / 60);
          p.life--;
          p.mesh.material.opacity = p.life / p.maxLife;
          if (p.life <= 0) { p.active = false; p.mesh.visible = false; }
        }
      }
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // [D] TEXTOS EMERGENTES 3D
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    class FloatingTexts {
      constructor(scene) { this.scene = scene; this.active = []; }

      spawn(text, pos, color = '#ffd166', scale = 1) {
        const c = document.createElement('canvas'); c.width = 512; c.height = 128;
        const ctx = c.getContext('2d');
        ctx.font = `bold 78px 'Courier New', monospace`;
        ctx.shadowColor = color; ctx.shadowBlur = 22;
        ctx.fillStyle = color;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.strokeStyle = 'rgba(0,0,0,0.95)'; ctx.lineWidth = 9;
        ctx.strokeText(text, 256, 64);
        ctx.fillText(text, 256, 64);
        const tex = new THREE.CanvasTexture(c);
        const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false, depthWrite: false });
        const sprite = new THREE.Sprite(mat);

        // Offset aleatorio para evitar solapamientos
        const nearby = this.active.filter(t =>
          Math.abs(t.sprite.position.x - pos.x) < 3 &&
          Math.abs(t.sprite.position.z - pos.z) < 4
        ).length;
        sprite.position.copy(pos);
        sprite.position.y += 1.2 + nearby * 1.6;
        sprite.position.x += (Math.random() - 0.5) * 2.2;
        sprite.scale.set(4 * scale, 1 * scale, 1);
        this.scene.add(sprite);
        this.active.push({ sprite, life: 90, maxLife: 90, vy: 0.022, scale, born: 0 });
      }

      update() {
        for (let i = this.active.length - 1; i >= 0; i--) {
          const t = this.active[i];
          t.born++;
          t.sprite.position.y += t.vy;
          const bounce = t.born < 14 ? 1 + Math.sin(t.born * 0.45) * 0.28 : 1;
          t.sprite.scale.set(4 * t.scale * bounce, 1 * t.scale * bounce, 1);
          t.life--;
          t.sprite.material.opacity = Math.min(1, t.life / t.maxLife * 1.5);
          if (t.life <= 0) { this.scene.remove(t.sprite); t.sprite.material.map.dispose(); this.active.splice(i, 1); }
        }
      }
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // [E] CÃMARA RIG (spring physics)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    class CameraRig {
      constructor(cam) {
        this.cam = cam;
        this.base = new THREE.Vector3(0, 8, 14);
        this.shakeAmt = 0;
        this.bobPhase = 0;
        this.tilt = 0; this.tiltTarget = 0;
      }
      shake(mag) { this.shakeAmt = Math.max(this.shakeAmt, mag); }
      update(playerX, speed, jumping) {
        this.shakeAmt *= 0.84;
        this.bobPhase += speed * 0.04;
        const bobY = jumping ? 0 : Math.sin(this.bobPhase) * 0.06;
        const shakeX = (Math.random() - 0.5) * this.shakeAmt;
        const shakeY = (Math.random() - 0.5) * this.shakeAmt * 0.5;
        this.tiltTarget = (playerX / 4.5) * -0.03;
        this.tilt += (this.tiltTarget - this.tilt) * 0.08;
        this.cam.position.set(
          this.base.x + shakeX,
          this.base.y + bobY + shakeY,
          this.base.z
        );
        this.cam.lookAt(this.base.x * 0.5, 1.5, -4);
        this.cam.rotation.z = this.tilt;
      }
      cinematic(targetPos, lookAt, t) {
        this.cam.position.lerp(targetPos, t);
        this.cam.lookAt(lookAt);
      }
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // [F] LÃNEAS DE VELOCIDAD
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    class SpeedLines {
      constructor(scene) {
        this.lines = [];
        const mat = new THREE.MeshBasicMaterial({ color: 0x4cc9f0, transparent: true, opacity: 0.4 });
        for (let i = 0; i < 30; i++) {
          const side = i < 15 ? -1 : 1;
          const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.04, 3 + Math.random() * 4), mat.clone());
          mesh.position.set((7 + Math.random() * 5) * side, -1 + Math.random() * 5, -20 + Math.random() * 50);
          scene.add(mesh); this.lines.push(mesh);
        }
      }
      update(speed) {
        const s = speed * 0.15;
        const alpha = Math.min(0.65, (speed - 4.8) * 0.05 + 0.1);
        for (const l of this.lines) {
          l.position.z += s;
          l.material.opacity = alpha;
          if (l.position.z > 14) { l.position.z = -50 + Math.random() * 10; }
        }
      }
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // [G] ENTORNO
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    class Environment {
      constructor(scene) {
        this.scene = scene;
        this.buildings = [];
        this._buildRoad();
        this._buildStars();
        this._buildBuildings();
        this.grid = this._buildGrid();
      }
      _buildRoad() {
        const road = new THREE.Mesh(new THREE.PlaneGeometry(16, 2000), new THREE.MeshPhongMaterial({ color: 0x0d1b2a, shininess: 30 }));
        road.rotation.x = -Math.PI / 2; road.receiveShadow = true; this.scene.add(road);
        const markMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 });
        for (let z = -80; z < 20; z += 4) {
          [-4.5, 0, 4.5].forEach(x => {
            const mark = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.01, 1.5), markMat);
            mark.position.set(x, 0.01, z); this.scene.add(mark);
          });
        }
        const edgeMat = new THREE.MeshBasicMaterial({ color: 0x4cc9f0 });
        [-8, 8].forEach(x => {
          const edge = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.1, 2000), edgeMat);
          edge.position.set(x, 0.05, 0); this.scene.add(edge);
        });
      }
      _buildGrid() {
        const grid = new THREE.GridHelper(400, 80, 0xffd166, 0x1a2a3a);
        grid.position.y = 0.02; this.scene.add(grid); return grid;
      }
      _buildStars() {
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(1200 * 3);
        for (let i = 0; i < 1200; i++) {
          pos[i * 3] = (Math.random() - 0.5) * 300;
          pos[i * 3 + 1] = 20 + Math.random() * 80;
          pos[i * 3 + 2] = (Math.random() - 0.5) * 300;
        }
        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        this.scene.add(new THREE.Points(geo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.25, transparent: true, opacity: 0.8 })));
      }
      _buildBuildings() {
        const winMat = new THREE.MeshBasicMaterial({ color: 0xffd166 });
        for (let i = 0; i < 20; i++) {
          const side = i < 10 ? -1 : 1;
          const w = 1.5 + Math.random() * 2, h = 4 + Math.random() * 8, d = 2 + Math.random() * 3;
          const g = new THREE.Group();
          const body = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshPhongMaterial({ color: 0x0d1117, emissive: 0x050810 }));
          body.position.y = h / 2; g.add(body);
          for (let r = 1; r < h; r += 1.2) {
            for (let c = 0; c < Math.floor(w / 0.7); c++) {
              if (Math.random() < 0.5) continue;
              const win = new THREE.Mesh(new THREE.PlaneGeometry(0.28, 0.32), winMat.clone());
              win.material.transparent = true;
              win.material.opacity = 0.4 + Math.random() * 0.5;
              win.position.set(-w / 2 + 0.35 + c * 0.7, r, d / 2 + 0.01);
              g.add(win);
            }
          }
          g.position.set((11 + Math.random() * 5) * side, -0.5, -10 + i * 12);
          this.scene.add(g); this.buildings.push(g);
        }
      }
      update(speed) {
        const s = speed * 0.12;
        this.grid.position.z = (this.grid.position.z + s * 0.85) % 5;
        for (const b of this.buildings) {
          b.position.z += s;
          if (b.position.z > 25) b.position.z -= 250;
        }
      }
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // [H] JUEGO PRINCIPAL
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    class SegarroDef {
      constructor() {
        this.audio = new Audio3D();
        this._initThree();
        this._initState();
        this._initScene();
        this._initInput();
        this._animate();
      }

      _initThree() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x0a0a14);
        this.scene.fog = new THREE.FogExp2(0x0a0a14, 0.018);

        this.camera = new THREE.PerspectiveCamera(65, innerWidth / innerHeight, 0.1, 1000);
        this.camera.position.set(0, 8, 14);
        this.camera.lookAt(0, 1.5, -4);

        this.renderer = new THREE.WebGLRenderer({ antialias: true, precision: 'highp' });
        this.renderer.setSize(innerWidth, innerHeight);
        this.renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.6;
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.getElementById('game-container').appendChild(this.renderer.domElement);

        // Luz hemisfÃ©rica intensa: cielo cÃ¡lido + suelo azulado
        const hemi = new THREE.HemisphereLight(0xfff0cc, 0x334466, 1.8);
        this.scene.add(hemi);

        // Sol principal â€” sombras nÃ­tidas
        const sun = new THREE.DirectionalLight(0xfff5e0, 3.5);
        sun.position.set(6, 22, 12); sun.castShadow = true;
        sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048;
        sun.shadow.camera.near = 0.5; sun.shadow.camera.far = 80;
        sun.shadow.camera.left = -12; sun.shadow.camera.right = 12;
        sun.shadow.camera.top = 12; sun.shadow.camera.bottom = -12;
        sun.shadow.bias = -0.0003;
        this.scene.add(sun);

        // Luz de relleno frontal fuerte (ilumina personajes que vienen de frente)
        const fill = new THREE.DirectionalLight(0xaabbff, 2.0);
        fill.position.set(0, 6, 20); this.scene.add(fill);

        // Rim light lateral para definir siluetas
        const rimL = new THREE.DirectionalLight(0x4cc9f0, 1.2);
        rimL.position.set(-8, 3, -10); this.scene.add(rimL);

        this.camRig = new CameraRig(this.camera);
        this.clock = new THREE.Clock();
        window.addEventListener('resize', () => {
          this.camera.aspect = innerWidth / innerHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(innerWidth, innerHeight);
        });
      }

      _initState() {
        this.estado = 'menu';
        this.score = 0;
        this.vel = 4.8;
        this.tiempo = 0;
        this.freqObs = 90;
        this.contObs = 0;
        this.pantallaRoja = 0;
        this.record = parseInt(localStorage.getItem('segarroRecord')) || 0;
        this.choquesSinMorir = 0;
        this.totalCigarrosReales = 0;
        this.combo = 0;
        this.ultimoBump = 0;

        this.j = {
          carril: 1, y: 0, vy: 0, saltando: false, agachado: false, enSuelo: true,
          vidas: 1, cigarros: 0, invulnerable: false, tiempoInv: 0,
          trucoEuro: { usado: false },
          pakiRicoh: { activo: false, contador: 0, duracion: 420 },
          enEscenaFinal: false, carrilCambiado: false
        };
        this.lanesX = [-4.5, 0, 4.5];
        this.obstacles = [];
        this.finalGroup = null;
        document.getElementById('record-display').textContent = `RÃ‰CORD: ${this.record}`;
      }

      _initScene() {
        this.env = new Environment(this.scene);
        this.particles = new ParticlePool(this.scene, 400);
        this.floatTexts = new FloatingTexts(this.scene);
        this.speedLines = new SpeedLines(this.scene);

        // Jugador 3D Mixamo FBX con animaciones reales
        this.playerMesh = FBXCharFactory.createPlayer();
        this.playerMesh.castShadow = true;
        this.scene.add(this.playerMesh);

        this._prepFinalScene();
      }

      _prepFinalScene() {
        this.finalGroup = new THREE.Group();
        const tableTop = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.1, 1.2), VF.m(0x6d4c41)); tableTop.position.set(0, 0.8, 0);
        const leg1 = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.8, 0.12), VF.m(0x4e342e)); leg1.position.set(-1.1, 0.4, -0.45);
        const leg2 = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.8, 0.12), VF.m(0x4e342e)); leg2.position.set(1.1, 0.4, -0.45);
        const leg3 = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.8, 0.12), VF.m(0x4e342e)); leg3.position.set(-1.1, 0.4, 0.45);
        const leg4 = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.8, 0.12), VF.m(0x4e342e)); leg4.position.set(1.1, 0.4, 0.45);
        this.finalGroup.add(tableTop, leg1, leg2, leg3, leg4);
        const hookah = VF.createHookah(); hookah.position.set(0, 0.85, 0); hookah.scale.setScalar(0.7);
        this.finalGroup.add(hookah);
        this.hookahLight = hookah.children.find(c => c.isLight);
        const sittingPlayer = VF.createAmigo(0xb07040, 0xf5f5f5);
        sittingPlayer.position.set(-1.5, 0, 0); this.finalGroup.add(sittingPlayer);
        const amigos = [
          [1.8, 0, -0.5, 0x795548, 0xd32f2f], [2.2, 0, 0.4, 0x5d4037, 0x1976d2],
          [-2.0, 0, 0.5, 0x8d6e63, 0x388e3c], [0, 0, 1.4, 0x6d4c41, 0xf57c00],
          [0, 0, -1.6, 0x5d4037, 0x7b1fa2]
        ];
        amigos.forEach(([x, y, z, skin, ropa]) => {
          const a = VF.createAmigo(skin, ropa); a.position.set(x, y, z); this.finalGroup.add(a);
        });
        this._creditoSprites = [];
        [['ESTE ES DEL BUENO', '#ffd166'], ['RESINA PEGAJOSA', '#ff4d4d'], ['la paz del segarrero', '#a5d6a7']].forEach(([txt, col], i) => {
          const cv = document.createElement('canvas'); cv.width = 512; cv.height = 80;
          const ctx2 = cv.getContext('2d');
          ctx2.font = `bold 60px 'Courier New'`; ctx2.fillStyle = col;
          ctx2.textAlign = 'center'; ctx2.textBaseline = 'middle';
          ctx2.shadowColor = col; ctx2.shadowBlur = 15;
          ctx2.fillText(txt, 256, 40);
          const sp = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(cv), transparent: true, depthTest: false }));
          sp.position.set(0, 3.5 - i * 1.2, 2);
          sp.scale.set(5, 1, 1);
          this.finalGroup.add(sp);
          this._creditoSprites.push(sp);
        });
        this.finalGroup.visible = false;
        this.scene.add(this.finalGroup);
      }

      _initInput() {
        document.getElementById('start-btn').addEventListener('click', () => {
          document.getElementById('title-screen').style.display = 'none';
          this.estado = 'jugando';
          this.audio.init();
          const msg = document.getElementById('audio-message');
          msg.classList.add('show'); setTimeout(() => msg.classList.remove('show'), 3000);
        });
        document.getElementById('restart-btn').addEventListener('click', () => location.reload());

        // TECLADO
        window.addEventListener('keydown', e => {
          if (this.estado !== 'jugando') return;
          switch (e.code) {
            case 'ArrowLeft': case 'KeyA': if (this.j.carril > 0) { this.j.carril--; this.j.carrilCambiado = true; } break;
            case 'ArrowRight': case 'KeyD': if (this.j.carril < 2) { this.j.carril++; this.j.carrilCambiado = true; } break;
            case 'ArrowUp': case 'KeyW': case 'Space':
              e.preventDefault();
              if (this.j.enSuelo) { this.j.vy = 0.32; this.j.enSuelo = false; this.j.saltando = true; this.audio.salto(); }
              break;
            case 'ArrowDown': case 'KeyS': this._agachar(); break;
          }
        });
        window.addEventListener('keyup', e => {
          if (e.code === 'ArrowDown' || e.code === 'KeyS') {
            this.j.agachado = false;
            const S = this.playerMesh.userData.baseScale || 1;
            this.playerMesh.scale.setScalar(S);
            this.playerMesh.position.y = this.j.y;
          }
        });

        // TÃCTIL con Truco â‚¬URO (3 swipes abajo rÃ¡pidos)
        let sx = 0, sy = 0, st = 0, swipesAbajo = 0, primerSwipeT = 0, resetEuroTimer = null;
        const resetEuro = () => { swipesAbajo = 0; primerSwipeT = 0; if (resetEuroTimer) clearTimeout(resetEuroTimer); };
        window.addEventListener('touchstart', e => { sx = e.touches[0].clientX; sy = e.touches[0].clientY; st = Date.now(); });
        window.addEventListener('touchend', e => {
          if (this.estado !== 'jugando') return;
          const dx = e.changedTouches[0].clientX - sx, dy = e.changedTouches[0].clientY - sy;
          if (Date.now() - st > 400) return;
          if (Math.abs(dx) > Math.abs(dy)) {
            resetEuro();
            if (dx > 30 && this.j.carril < 2) { this.j.carril++; this.j.carrilCambiado = true; }
            if (dx < -30 && this.j.carril > 0) { this.j.carril--; this.j.carrilCambiado = true; }
          } else {
            if (dy < -30 && this.j.enSuelo) { resetEuro(); this.j.vy = 0.32; this.j.enSuelo = false; this.j.saltando = true; this.audio.salto(); }
            else if (dy > 30 && dy < 60) { resetEuro(); this._agachar(); }
            else if (dy >= 60) {
              const now = Date.now();
              if (swipesAbajo === 0) { primerSwipeT = now; swipesAbajo = 1; }
              else if (now - primerSwipeT < 1000) { swipesAbajo++; if (swipesAbajo >= 3 && !this.j.trucoEuro.usado) { this._activarEuro(); resetEuro(); return; } }
              else { resetEuro(); swipesAbajo = 1; primerSwipeT = now; }
              if (resetEuroTimer) clearTimeout(resetEuroTimer);
              resetEuroTimer = setTimeout(resetEuro, 1000);
            }
          }
        });
      }

      _agachar() {
        if (this.j.agachado || !this.j.enSuelo) return;
        this.j.agachado = true;
        const S = this.playerMesh.userData.baseScale || 1;
        this.playerMesh.scale.set(S * 0.75, S * 0.29, S);
      }

      _activarEuro() {
        if (this.j.trucoEuro.usado || this.j.pakiRicoh.activo || this.j.enEscenaFinal) return;
        this.j.trucoEuro.usado = true;
        this.estado = 'pausado_truco';
        this.j.vidas++;
        document.getElementById('vidas-count').textContent = this.j.vidas;
        const pos = new THREE.Vector3(this.lanesX[this.j.carril], this.j.y + 2, 0);
        this.floatTexts.spawn('â‚¬URO', pos, '#ffd700', 2.0);
        this.particles.emit(pos, 0xffd700, 40, 6, 60, 0.04);
        this.camRig.shake(0.5);
        this.audio.euro();
        setTimeout(() => { if (this.estado === 'pausado_truco') this.estado = 'jugando'; }, 2000);
      }

      _activarPaki() {
        this.j.pakiRicoh.activo = true;
        this.j.pakiRicoh.contador = 0;
        const pos = new THREE.Vector3(0, 3, 0);
        this.floatTexts.spawn('Â¡PAKI RICOH!', pos, '#ffd700', 1.8);
        this.particles.emit(pos, 0xffd700, 60, 8, 80, 0.03);
        this.camRig.shake(0.45);
        this.audio.pakiOn();
        // Tinte dorado en materiales FBX + aura
        this.playerMesh.userData.auraLight.intensity = 3.5;
        this.playerMesh.traverse(c => {
          if ((c.isMesh || c.isSkinnedMesh) && c.material) {
            const mats = Array.isArray(c.material) ? c.material : [c.material];
            mats.forEach(m => { m.emissive = new THREE.Color(0.4, 0.28, 0); });
          }
        });
        document.getElementById('paki-bar-wrap').style.display = 'block';
      }

      _terminarPaki() {
        this.j.pakiRicoh.activo = false;
        this.playerMesh.userData.auraLight.intensity = 0;
        this.playerMesh.traverse(c => {
          if ((c.isMesh || c.isSkinnedMesh) && c.material) {
            const mats = Array.isArray(c.material) ? c.material : [c.material];
            mats.forEach(m => { m.emissive = new THREE.Color(0, 0, 0); });
          }
        });
        document.getElementById('paki-bar-wrap').style.display = 'none';
        const pos = new THREE.Vector3(this.lanesX[this.j.carril], this.j.y + 2, 0);
        this.floatTexts.spawn('...', pos, '#aaaaaa', 0.9);
        this.audio.tos();
      }

      _spawn() {
        if (this.contObs < this.freqObs) { this.contObs++; return; }
        // Si los obstÃ¡culos aÃºn no han cargado (fase 2 en background), esperar
        if (!FBXCharFactory.obstaclesReady) { this.contObs = Math.floor(this.freqObs * 0.5); return; }
        this.contObs = 0;
        const lane = Math.floor(Math.random() * 3), r = Math.random();
        let type, mesh, rapido = false;
        if (r < 0.45) { type = 'poli'; rapido = false; mesh = FBXCharFactory.createPolicia(false); }
        else if (r < 0.67) { type = 'poli'; rapido = true; mesh = FBXCharFactory.createPolicia(true); }
        else if (r < 0.75) { type = 'cerdo'; mesh = FBXCharFactory.createCerdo(); }
        else { type = 'cig'; mesh = VF.createCigarro(); mesh.scale.setScalar(1.1); }

        mesh.position.set(this.lanesX[lane], 0, -90);
        this.scene.add(mesh);
        this.obstacles.push({ mesh, type, rapido, lane, flotOffset: Math.random() * Math.PI * 2 });
      }

      // â”€â”€ Hitbox custom para sprites articulados â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      _hitBox(group, forPlayer = false) {
        const pos = group.position;
        const ud = group.userData;
        const gy = group.scale.y;
        // Sprites segmentados exponen totalH y w directamente
        const mul = forPlayer ? 0.78 : 0.83;
        const h = ud.totalH ? ud.totalH * gy * mul
          : ud.sprite ? ud.sprite.scale.y * gy * mul : 2.0;
        const w = ud.w ? ud.w * 0.30
          : ud.sprite ? ud.sprite.scale.x * 0.30 : 0.5;
        return new THREE.Box3(
          new THREE.Vector3(pos.x - w, pos.y, pos.z - 0.9),
          new THREE.Vector3(pos.x + w, pos.y + h, pos.z + 0.9)
        );
      }

      _updateJugador() {
        // Movimiento lateral suave
        const tx = this.lanesX[this.j.carril];
        this.playerMesh.position.x += (tx - this.playerMesh.position.x) * 0.15;

        // Salto
        if (!this.j.enSuelo) {
          this.j.vy -= 0.018;
          this.j.y += this.j.vy;
          if (this.j.y <= 0) { this.j.y = 0; this.j.enSuelo = true; this.j.saltando = false; this.j.vy = 0; }
        }

        // Si se suelta agachar mientras salta en el aire, restaurar
        if (this.j.agachado && !this.j.enSuelo) {
          this.j.agachado = false;
          const S = this.playerMesh.userData.baseScale || 1;
          this.playerMesh.scale.setScalar(S);
        }

        // PosiciÃ³n del personaje
        if (!this.j.agachado) {
          this.playerMesh.position.y = this.j.y;
        }

        // Fix underground: forzar posiciÃ³n Y del modelo interno a 0 relativo
        if (this.playerMesh._inner) this.playerMesh._inner.position.y = 0;

        // â”€â”€ MÃ¡quina de estados de animaciÃ³n FBX â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const ud = this.playerMesh.userData;
        if (ud.isFBX) {
          // TransiciÃ³n Run â†’ Jump al despegar
          if (this.j.saltando && !ud.prevSaltando) {
            ud.runAction.fadeOut(0.1);
            ud.jumpAction.reset().fadeIn(0.1).play();
          }
          // TransiciÃ³n Jump â†’ Run al aterrizar
          if (!this.j.saltando && ud.prevSaltando) {
            ud.jumpAction.fadeOut(0.15);
            ud.runAction.reset().fadeIn(0.15).play();
          }
          // AnimaciÃ³n de cambio de carril (se reproduce una vez)
          if (this.j.carril !== ud.prevCarril && ud.changeAction) {
            ud.changeAction.reset().setEffectiveWeight(0.8).play();
          }
          // timeScale: la animaciÃ³n de correr se acelera con la velocidad del juego
          ud.runAction.timeScale = 0.6 + (this.vel - 1.8) * 0.1;
          ud.prevSaltando = this.j.saltando;
          ud.prevCarril   = this.j.carril;
        }

        // Invulnerabilidad â€” parpadeo del sprite
        if (this.j.invulnerable) {
          this.j.tiempoInv--;
          if (this.j.tiempoInv <= 0) this.j.invulnerable = false;
          const blink = Math.floor(Date.now() / 80) % 2 === 0;
          const op = blink ? 0.15 : 1;
          this.playerMesh.traverse(c => {
            if (c.isMesh) { c.material.transparent = true; c.material.opacity = op; }
            if (c.isSprite) { c.material.opacity = op; }
          });
        } else {
          this.playerMesh.traverse(c => {
            if (c.isMesh) { c.material.transparent = false; c.material.opacity = 1; }
            if (c.isSprite) { c.material.opacity = 1; }
          });
        }

        // Paki Ricoh timer + humo dorado
        if (this.j.pakiRicoh.activo) {
          this.j.pakiRicoh.contador++;
          document.getElementById('paki-bar').style.width = `${100 * (1 - this.j.pakiRicoh.contador / this.j.pakiRicoh.duracion)}%`;
          if (this.tiempo % 3 === 0) {
            const p = new THREE.Vector3(
              this.lanesX[this.j.carril] + (Math.random() - 0.5) * 0.6,
              this.j.y + 1.5 + (Math.random() * 1.8),
              0
            );
            this.particles.emit(p, 0xffd700, 1, 0.4, 55, -0.012);
          }
          // Pulso en la luz aura
          this.playerMesh.userData.auraLight.intensity = 3.0 + Math.sin(this.tiempo * 0.15) * 1.0;
          if (this.j.pakiRicoh.contador >= this.j.pakiRicoh.duracion) this._terminarPaki();
        }

        // AnimaciÃ³n cigarro: brillo pulsante + giro suave + flotaciÃ³n
        for (const obs of this.obstacles) {
          if (obs.type === 'cig' && obs.mesh.userData.light) {
            const pulse = 2.0 + Math.sin(this.tiempo * 0.15) * 1.2;
            obs.mesh.userData.light.intensity = pulse;
            if (obs.mesh.userData.glow) {
              obs.mesh.userData.glow.material.opacity = 0.28 + Math.sin(this.tiempo * 0.15) * 0.14;
              obs.mesh.userData.glow.scale.setScalar(0.8 + Math.sin(this.tiempo * 0.10) * 0.28);
            }
            obs.mesh.position.y = 1.1 + Math.sin(this.tiempo * 0.09 + (obs.flotOffset || 0)) * 0.3;
            obs.mesh.rotation.y += 0.013; // giro lento y seductor
          }
        }

        // Luz roja de policÃ­as rÃ¡pidos: pulsa
        for (const obs of this.obstacles) {
          if (obs.rapido && obs.mesh.userData.rLight) {
            obs.mesh.userData.rLight.intensity = 1.5 + Math.sin(this.tiempo * 0.3) * 1.2;
          }
        }
      }

      _updateObstacles() {
        const pBox = this._hitBox(this.playerMesh, true);
        for (let i = this.obstacles.length - 1; i >= 0; i--) {
          const ob = this.obstacles[i];
          const spd = ob.type === 'cerdo' ? 1.8 : this.vel + (ob.rapido ? 1.3 : 0);
          ob.mesh.position.z += spd * 0.12;

          // Velocidad de animaciÃ³n FBX segÃºn tipo de obstÃ¡culo
          const udOb = ob.mesh.userData;
          if (udOb.isFBX && udOb.runAction) {
            udOb.runAction.timeScale = ob.type === 'cerdo' ? 0.7 : (ob.rapido ? 1.6 : 1.0);
          }

          if (ob.mesh.position.z > 12) { this.scene.remove(ob.mesh); this.obstacles.splice(i, 1); continue; }
          if (!this.j.invulnerable || ob.type === 'cig') {
            const eBox = this._hitBox(ob.mesh, false);
            if (pBox.intersectsBox(eBox)) this._onCollision(ob, i);
          }
        }
      }

      _onCollision(ob, idx) {
        const pos = new THREE.Vector3().copy(ob.mesh.position);
        pos.y += 1.5;
        if (ob.type === 'cig') {
          this.j.cigarros++;
          this.totalCigarrosReales++;
          this.combo++;
          this.audio.suspiro();
          this.floatTexts.spawn(this.combo > 1 ? `SEGARRO x${this.combo}` : 'SEGARRO', pos, '#ffd166', this.combo > 1 ? 1.3 : 1);
          this.particles.emit(pos, 0xffd166, 15, 4, 40, 0.05);
          document.getElementById('cigarros-count').textContent = this.j.cigarros;
          if (this.j.cigarros >= 5) {
            this.j.vidas++; this.j.cigarros = 0;
            document.getElementById('cigarros-count').textContent = 0;
            document.getElementById('vidas-count').textContent = this.j.vidas;
            this.floatTexts.spawn('AMIGOO', pos, '#ffd700', 1.8);
            this.particles.emit(pos, 0xffd700, 35, 6, 60, 0.04);
            this.camRig.shake(0.35);
            this.audio.vida();
          }
          if (this.totalCigarrosReales % 10 === 0 && this.totalCigarrosReales > 0) this._activarPaki();
        } else {
          if (this.j.pakiRicoh.activo) {
            if (Math.random() < 0.3) this.floatTexts.spawn('RECISTA', pos, '#ff4d4d');
            this.scene.remove(ob.mesh); this.obstacles.splice(idx, 1); return;
          }
          if (!this.j.invulnerable) {
            const ppos = new THREE.Vector3(this.lanesX[this.j.carril], this.j.y + 1.5, 0);
            const color = ob.type === 'cerdo' ? 0xff80ab : 0xff4d4d;
            this.particles.emit(ppos, color, 30, 6, 55, 0.06);
            this.camRig.shake(ob.type === 'cerdo' ? 0.75 : 0.55);
            this.pantallaRoja = 30;
            this.combo = 0;
            this.choquesSinMorir++;
            const txt = ob.type === 'cerdo' ? 'YALLAH' : 'RECISTA';
            this.floatTexts.spawn(txt, pos, '#ff4d4d', ob.type === 'cerdo' ? 1.5 : 1);
            if (this.choquesSinMorir >= 3) {
              this.floatTexts.spawn('MI CARTERAÂ¡', pos, '#ffd166', 1.6);
              this.choquesSinMorir = 0;
            }
            if (ob.type === 'cerdo') this.audio.cerdo(); else this.audio.choque();
            this.j.vidas--;
            document.getElementById('vidas-count').textContent = this.j.vidas;
            if (this.j.vidas <= 0) { this.scene.remove(ob.mesh); this.obstacles.splice(idx, 1); this._gameOver(); return; }
            this.j.invulnerable = true; this.j.tiempoInv = 90;
          }
        }
        this.scene.remove(ob.mesh); this.obstacles.splice(idx, 1);
      }

      _updateDificultad() {
        this.score++;
        if (this.score - this.ultimoBump >= 100) {
          const sd = document.getElementById('score-display');
          sd.classList.add('bump'); setTimeout(() => sd.classList.remove('bump'), 100);
          this.ultimoBump = this.score;
        }
        document.getElementById('score-display').textContent = `SCORE: ${this.score}`;
        // Rampa gradual: sube de 1.8 a 4.8 en los primeros 90 segundos (~5400 frames)
        const BASE_VEL = Math.min(4.8, 1.8 + (this.tiempo / 5400) * 3.0);
        this.vel = BASE_VEL;
        if (this.score >= 1000) this.vel += 0.6;
        if (this.score >= 2000) this.vel += 0.6;
        if (this.score >= 3500) this.vel += 0.6;
        if (this.score >= 5500) this.vel += 0.6;
        if (this.score >= 8000) this.vel += 0.6;
        if (this.score >= 11000) this.vel += 0.6;
        if (this.score >= 15000) this.vel += 0.6;
        document.getElementById('speed-bar').style.width = `${Math.min(100, 20 + ((this.vel - 4.8) / 4.2) * 80)}%`;
        if (this.score % 1200 === 0 && this.freqObs > 40) this.freqObs -= 6;
        if (this.score >= 30000 && this.estado !== 'final') this._escenaFinal();
      }

      _actualizarCombo() {
        const el = document.getElementById('combo-display');
        if (this.combo > 1) { el.textContent = `x${this.combo}`; el.classList.add('show'); }
        else el.classList.remove('show');
      }

      _pantallaRojaUpdate() {
        if (this.pantallaRoja > 0) {
          this.pantallaRoja--;
          document.getElementById('red-flash').style.opacity = this.pantallaRoja / 40;
        }
      }

      _escenaFinal() {
        this.estado = 'final';
        this.j.enEscenaFinal = true;
        this.audio.stopMusica();
        for (const ob of this.obstacles) { this.scene.remove(ob.mesh); }
        this.obstacles = [];
        const fade = document.getElementById('fade-overlay');
        fade.classList.add('active');
        setTimeout(() => {
          this.playerMesh.visible = false;
          this.finalGroup.visible = true;
          this.finalGroup.position.set(0, 0, -5);
          this.env.buildings.forEach(b => { b.visible = false; });
          fade.classList.remove('active');
          if (this.audio.ctx) {
            const notas = [110, 130.81, 146.83]; let ni = 0;
            const lentaPlay = () => {
              if (this.estado !== 'final') return;
              const o = this.audio.ctx.createOscillator(), g = this.audio.ctx.createGain();
              o.connect(g); g.connect(this.audio.ctx.destination);
              o.type = 'sine'; o.frequency.value = notas[ni];
              g.gain.setValueAtTime(0.05, this.audio.ctx.currentTime);
              g.gain.linearRampToValueAtTime(0, this.audio.ctx.currentTime + 1.2);
              o.start(); o.stop(this.audio.ctx.currentTime + 1.4);
              ni = (ni + 1) % notas.length; setTimeout(lentaPlay, 1800);
            }; lentaPlay();
          }
        }, 850);
      }

      _gameOver() {
        this.estado = 'gameover';
        if (this.score > this.record) {
          this.record = this.score;
          localStorage.setItem('segarroRecord', this.record);
          document.getElementById('record-display').textContent = `RÃ‰CORD: ${this.record}`;
        }
        document.getElementById('final-score').textContent = `SCORE: ${this.score}`;
        document.getElementById('best-record').textContent = `MEJOR RÃ‰CORD: ${this.record}`;
        document.getElementById('game-over').classList.add('show');
        this.camRig.shake(1.2);
        const pos = new THREE.Vector3(0, 3, 0);
        this.particles.emit(pos, 0xff4d4d, 60, 8, 80, 0.05);
        this.audio.gameOver();
        this.audio.stopMusica();
      }

      _updateFinalScene() {
        const target = new THREE.Vector3(10, 5, 2);
        const lookAt = new THREE.Vector3(0, 1.5, -5);
        this.camRig.cinematic(target, lookAt, 0.015);
        if (this.tiempo % 6 === 0 && this.hookahLight) {
          const p = new THREE.Vector3(0, 3.5, -5);
          p.x += (Math.random() - 0.5) * 0.5;
          this.particles.emit(p, 0xbbbbbb, 2, 0.4, 80, -0.01);
        }
        if (this._creditoSprites) {
          this._creditoSprites.forEach((sp, i) => {
            sp.position.y = 3.5 - i * 1.2 + Math.sin(this.tiempo * 0.02 + i) * 0.1;
          });
        }
        if (this.hookahLight) this.hookahLight.intensity = 1.0 + Math.sin(this.tiempo * 0.07) * 0.5;
      }

      _update() {
        if (this.estado === 'final') {
          this.tiempo++;
          this._updateFinalScene();
          this.particles.update();
          this.floatTexts.update();
          return;
        }
        if (this.estado !== 'jugando' && this.estado !== 'pausado_truco') return;
        this.tiempo++;
        this._updateJugador();
        if (this.estado === 'jugando' && !this.j.enEscenaFinal) {
          this._spawn();
          this._updateObstacles();
          this._updateDificultad();
        }
        this._actualizarCombo();
        this._pantallaRojaUpdate();
        this.particles.update();
        this.floatTexts.update();
        this.env.update(this.vel);
        this.speedLines.update(this.vel);
        this.camRig.update(this.playerMesh.position.x, this.vel, this.j.saltando);
        this.camRig.base.x += (this.playerMesh.position.x * 0.05 - this.camRig.base.x) * 0.08;
      }

      _updateMixers(delta) {
        if (this.playerMesh?.userData?.mixer) this.playerMesh.userData.mixer.update(delta);
        for (const ob of this.obstacles) {
          if (ob.mesh?.userData?.mixer) ob.mesh.userData.mixer.update(delta);
        }
      }

      _animate() {
        requestAnimationFrame(() => this._animate());
        this._updateMixers(this.clock.getDelta());
        this._update();
        this.renderer.render(this.scene, this.camera);
      }
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ARRANQUE ASÃNCRONO â€” carga progresiva en 2 fases
    //
    //  Fase 1 (bloqueante): protagonista.glb con 3 animaciones â†’ tÃ­tulo visible
    //  Fase 2 (background): policia.glb + cerdo.glb            â†’ listo antes del primer spawn
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async function main() {
      // Fase 1: protagonista.glb (Correr + Saltar + Girar)
      await FBXCharFactory.loadPhase1();

      // Mostrar el menÃº sin esperar a los obstÃ¡culos
      document.getElementById('load-screen').style.display = 'none';
      document.getElementById('title-screen').style.display = 'flex';
      new SegarroDef();

      // Fase 2: policÃ­a + cerdo en background mientras el usuario estÃ¡ en el menÃº
      // _spawn() espera automÃ¡ticamente a que obstaclesReady sea true
      FBXCharFactory.loadPhase2();
    }
    main();
  </script>
</body>

</html>